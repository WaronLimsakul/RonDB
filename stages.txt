step 1
should be able to
1. input somethign and got unrecognized "error"
2. or if .exit -> exit

step 2
1. recognize meta command
2. know insert and select command type

step 3.1
1. support inseting a row + printing all rows
    - this format "insert id name email" or "select"
    - yes, we have id -> int, name -> varchar32, email -> varchar255 (why not 256?)
2. only in memory
3. support single hardcoded table
- there is sscanf(), like scanf but the read from first argument instead.
- try to enum the error type
- use prepro macro to define sizes or compile time var

step3.2
- Store rows in blocks of memory called pages
- Each page stores as many rows as it can fit
- Rows are serialized into a compact representation with each page
- Pages are only allocated as needed <- so we can't just malloc(100 * page)
- Keep a fixed-size array of pointers to pages

1. a table struct that keep track of
    - how many rows are in the table right now
    - addresses of each page
(you can determine size of page and max number of page in the table)
    1.1 a function that create new table and set all zeroes
    1.2 a function that frees table
2. a function that get a row address from just table and row number.
    - can allocate a new page if it doesn't exit
3. delegate insert and select to different functions
4. have a const representing the executing result for both execution type to share
5. execute insert already row from the statement so we can just copy the row into the table (don't forget to check the max cap)
6. execute select by just loop and print each row, be cheap here.

step 5
1. have a Pager struct to manage page instead of using just page array in table
    - a page is just one chunk of bytes in a file on disk
    - we will store all pages in the same file.
2. redo the new_table into db_open(file_name). it should
    - open db file
    - init pager
    - init table
    *note that we know the length of the file after we open it
3. note the flags for open(filename, flags, mode): flags is what programm gonna
    do with the file, mode is what can user do with the file.
4. move the logic for fetching a page into pager's own method:
5. get_page() method should have logic handling the cache miss (allocate memory and load from file)

step 5.2
1. we need db_close(table)
    - flush cahced pages to disk (deal with full and partial page separately)
    - close db file
    - free all pages + pager + table
2. just db_close() when exit (so do_meta_command() need table now)
3. we need pager_flush(pager, page_num, size)
    - just write the page into the file in proper location
4. update main() to take more db file when called

step 6: cursor
1. we need cursor struct.
2. then we can get cursor from the start or the end of table
3. retrieving the row pointer using cursor instead
4. use cursor when execute insert and select
